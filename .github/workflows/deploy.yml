name: CI/CD Pipeline

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  SERVICE_NAME: clipvault-public-api
  REGION: us-central1
  ENVIRONMENT: staging

jobs:
  test:
    name: Test and Lint
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'
        
    - name: Install Poetry
      uses: snok/install-poetry@v1
      with:
        version: 1.7.1
        virtualenvs-create: true
        virtualenvs-in-project: true
        
    - name: Load cached venv
      id: cached-poetry-dependencies
      uses: actions/cache@v3
      with:
        path: .venv
        key: venv-${{ runner.os }}-${{ steps.setup-python.outputs.python-version }}-${{ hashFiles('**/poetry.lock') }}
        
    - name: Install dependencies
      if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true'
      run: poetry install --no-interaction --no-root
      
    - name: Install project
      run: poetry install --no-interaction
      
    - name: Run linting
      run: |
        poetry run ruff check .
        poetry run ruff format --check .
        
    - name: Run type checking
      run: poetry run mypy .
      
    - name: Run tests
      run: poetry run pytest tests/ -v --cov=api --cov-report=xml
      
    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
        flags: unittests
        name: codecov-umbrella

  security:
    name: Security Scan
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'
        
    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  build-and-deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    needs: [test]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    permissions:
      contents: read
      id-token: write
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        workload_identity_provider: ${{ secrets.WIF_PROVIDER }}
        service_account: ${{ secrets.WIF_SERVICE_ACCOUNT }}
        
    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v2
      
    - name: Configure Docker for Artifact Registry
      run: gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev
      
    - name: Get Artifact Registry URL
      id: registry
      run: |
        REPO_URL="${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.SERVICE_NAME }}-${{ env.ENVIRONMENT }}"
        echo "url=${REPO_URL}" >> $GITHUB_OUTPUT
        echo "image=${REPO_URL}/${{ env.SERVICE_NAME }}:${{ github.sha }}" >> $GITHUB_OUTPUT
        echo "latest=${REPO_URL}/${{ env.SERVICE_NAME }}:latest" >> $GITHUB_OUTPUT
        
    - name: Build Docker image
      run: |
        docker build \
          -f docker/Dockerfile \
          -t ${{ steps.registry.outputs.image }} \
          -t ${{ steps.registry.outputs.latest }} \
          .
          
    - name: Push Docker image
      run: |
        docker push ${{ steps.registry.outputs.image }}
        docker push ${{ steps.registry.outputs.latest }}
        
    - name: Set up Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.6.0
        
    - name: Terraform Init
      working-directory: ./infra
      run: terraform init
      
    - name: Terraform Plan
      working-directory: ./infra
      run: |
        terraform plan \
          -var="project_id=${{ env.PROJECT_ID }}" \
          -var="environment=${{ env.ENVIRONMENT }}" \
          -var="container_image=${{ steps.registry.outputs.image }}" \
          -var="supabase_url=${{ secrets.SUPABASE_URL }}" \
          -var="supabase_anon_key=${{ secrets.SUPABASE_ANON_KEY }}" \
          -var="supabase_service_role_key=${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
          -var="redis_url=${{ secrets.REDIS_URL }}" \
          -out=tfplan
          
    - name: Terraform Apply
      working-directory: ./infra
      run: terraform apply -auto-approve tfplan
      
    - name: Get service URL
      id: service
      working-directory: ./infra
      run: |
        SERVICE_URL=$(terraform output -raw service_url)
        echo "url=${SERVICE_URL}" >> $GITHUB_OUTPUT
        echo "Service deployed to: ${SERVICE_URL}"
        
    - name: Test deployment
      run: |
        echo "Testing deployment health check..."
        sleep 30  # Wait for service to be ready
        curl -f ${{ steps.service.outputs.url }}/ping
        echo "âœ… Deployment successful!"
        
    - name: Comment deployment URL
      uses: actions/github-script@v7
      if: github.event_name == 'push'
      with:
        script: |
          const { data: commits } = await github.rest.repos.listCommits({
            owner: context.repo.owner,
            repo: context.repo.repo,
            sha: context.sha,
            per_page: 1
          });
          
          const commit = commits[0];
          if (commit) {
            await github.rest.repos.createCommitComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha,
              body: `ðŸš€ **Deployment successful!**\n\n**Service URL:** ${{ steps.service.outputs.url }}\n**Environment:** ${{ env.ENVIRONMENT }}\n**Image:** ${{ steps.registry.outputs.image }}`
            });
          } 